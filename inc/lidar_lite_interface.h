/*
Copyright (c) 2017 Garmin Ltd. or its subsidiaries.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#ifndef __LIDAR_LITE_INTERFACE__
#define __LIDAR_LITE_INTERFACE__

#include <stdint.h>
#include <stdbool.h>
#include "nrf_error.h"
#include "nrfx_spim.h"
#include "nrf_drv_gpiote.h"
#include "lidar_lite_defines.h"
#include "soc_error_handler.h"
#include "soc_logger.h"

/** @brief Lidar Lite Library Initialization
 *
 * @param[in] use_scheduler     Set to true to configure all events for the drivers to interface with the FPGA to be handled using
 *                              the Nordic SDK scheduling library (app_scheduler).
 *                              Set to false if the application is not using app_scheduler. In that case, the application must set up
 *                              all of the event handlers in @ref fpga_event_handlers manually.
 *
 *                              TIMER1 is being accessed through register writes.
 *                              NOTE: If timers are going to be used by third parties TIMER1 can not be used
 *
 * @param[in] event_handler     Pointer to Lidar Lite event handler.
 *
 * @param[in] error_handler     Pointer to function that will handle errors generated by library.  This must be implemented by the
 *                              application so it can be registered by the library as it is being initialized.
 *                              USE_SOC_LIBRARY_APP_ERROR must be added as a compiler option
 *
 * @param[in] log handler       Pointer to general logging handler.  Routine must be added to main application code.
 *
 * @retval NRF_SUCCESS Initialization successful
 */
ret_code_t lidar_lite_init(bool use_scheduler, lidar_lite_event_handler_t event_handler, soc_lib_error_handler_t error_handler, soc_log_handler_t log_handler);

/**
 * \defgroup fpga_event_handlers Event Handlers for communication with FPGA
 * Functions in this group can be used to change how events from the drivers used to communicate with the FPGA are handled by
 * the application (e.g. to integrate with an RTOS).  If the option to use_scheduler is selected when initializing the
 * LIDAR Lite Library, it is not necessary for the application to use any of these functions.
 * @{
 */

/** @brief LIDAR Lite FPGA SPI and Interrupt Line initialization.
 *
 * @details The event handlers for the drivers used to communicate with the FPGA are exposed to the application in case it requires
 *          customizing the scheduling of incoming events (e.g. for integration with an RTOS).
 *          The spi_event should be passed back into @ref lidar_lite_serial_fpga_event_handler and the interrupt_line_event should be
 *          passed back into @ref lidar_lite_serial_fpga_interrupt_event_handler so that they can be properly processed by the library.
 *          If the option to use_scheduler is enabled when calling @ref lidar_lite_init, the initialization of the event handlers is performed
 *          by the library, and it is not necessary to call this function from the application.
 * @param[in] lidar_lite_spi_event_handler  Event handler for SPI events
 * @param[in] lidar_lite_interrupt_line_event_handler   Event handler for additional GPIO used to interface to FPGA
 *
 */
void lidar_lite_serial_fpga_init(nrfx_spim_evt_handler_t lidar_lite_spi_event_handler, nrf_drv_gpiote_evt_handler_t lidar_lite_interrupt_line_event_handler);

/** @brief Handle SPI events
 *
 * @details Application should pass incoming SPI events into this function so they may be processed by the Lidar Lite library.
 *
 * @param[in] p_event_data      Event data (use a pointer to @ref nrf_drv_spi_evt_t)
 * @param[in] event_size        Size of event data
 */
void lidar_lite_serial_fpga_event_handler(void * p_event_data, uint16_t event_size);

/** @brief Handle FPGA interrupt events
 *
 * @details Application should pass incoming FPGA interrupt line events into this function so they may be processed by the Lidar Lite library.
 *
 * @param[in] p_event_data      Event data (use a pointer to @ref nrf_drv_gpiote_pin_t)
 * @param[in] event_size        Size of event data
 */
void lidar_lite_serial_fpga_interrupt_event_handler(void * p_event_data, uint16_t event_size);

 /** @brief Handle FPGA trace pin interrupt events
 *
 * @details Application should pass incoming FPGA trace pin (GPIOTE) events into this function so they may be processed by the Lidar Lite library.
 *
 * @param[in] p_event_data    Event data (use a pointer to @ref nrf_drv_gpiote_pin_t)
 * @param[in] event_size      Size of event data
 */
void lidar_lite_trace_fpga_interrupt_event_handler(void * p_event_data, uint16_t event_size);

/**@}*/


 /** @brief  Request a distance measurement from the Lidar Lite Library
 *
 * @details  Faster distance measurements can be performed by omitting the receiver bias correction routine.
 *           Measurement accuracy and sensitivity are adversely affected if conditions change (e.g. target distance,
 *           device temperature, and optical noise). To achieve good performance at high measurement rates
 *           receiver bias correction must be performed periodically. The recommended method is to do so at the
 *           beginning of every 100 sequential measurement commands.
 *
 * @param[in]   use_receiver_bias_correction      Set to true to take a distance measurement with a receiver bias correction
 *
 * @retval      LIDAR_LITE_SUCCESS                The distance measurement was successfully requested
 * @retval      LIDAR_LITE_ERROR_INCORRECT_STATE  A distance measurement could not be started because the Lidar Lite Library is not in
 *                                                the correct state. Either power on the device and wait for LIDAR_LITE_EVT_POWER_UP_COMPLETE,
 *                                                or wait for LIDAR_LITE_EVT_MEASUREMENT_COMPLETE indicating that the current distance
 *                                                measurement that is currently in progress is complete.
 */
lidar_lite_return_t lidar_lite_request_measurement(bool use_receiver_bias_correction);


 /** @brief  Sets the Lidar Lite Library Detection Sensitivity
 *
 * @details  The default valid measurement detection algorithm is based on the peak value, signal strength, and noise in the correlation record.
 *           This can be overridden to become a simple threshold criterion by setting a non-zero value.
 *           Recommend non-default values are 0x20 for higher sensitivity with more frequent erroneous measurements,
 *           and 0x60 for reduced sensitivity and fewer erroneous measurements.
 *
 * @param[in]   threshold               Set to the desired detection threshold override value.
 *                                      Set to 0x00 for the default automatic Lidar Lite Library threshold detection algorithm
 *
 * @retval      LIDAR_LITE_SUCCESS      The detection threshold was successfully set
 */
lidar_lite_return_t lidar_lite_set_detection_sensitivity(uint8_t threshold);

 /** @brief  Get the current Detection Sensitivity configuration
 *
 * @param[out]  current_threshold_value   The libraries current detection sensitivity configuration.
 *
 * @retval      LIDAR_LITE_SUCCESS        The detection threshold was retrieved successfully
 */
lidar_lite_return_t lidar_lite_get_detection_sensitivity(uint8_t * current_threshold_value);


 /** @brief  Read a single element from the correlation record
 *
 * @details  Call this function consecutively to obtain the entire correlation record.
 *           Each consecutive call to this function will move the internal the correlation record pointer.
 *           If the pointer reaches the end of the correlation record, the pointer will reset to the start
 *           of the correlation record. The internal pointer is reset each time a distance measurement is taken.
 *
 * @param[out]  corr_data                 The two byte signed correlation record value.
 *
 * @retval      LIDAR_LITE_SUCCESS        The element was retrieved successfully from the correlation record.
 */
lidar_lite_return_t lidar_lite_get_element_from_correlation_record(int16_t * corr_data);

 /** @brief  Reset the correlation record pointer
 *
 * @retval      LIDAR_LITE_SUCCESS        The internal pointer/counter was to zero
 */
lidar_lite_return_t lidar_lite_reset_correlation_record_pointer();

 /** @brief  Retrieve the Lidar Lite Library Version
 *
 * @param[in]   version_string          Pointer to the library version string.
 *
 * @retval      LIDAR_LITE_SUCCESS      The library version was retrieved successfully
 */
lidar_lite_return_t lidar_lite_request_library_version(const char ** version_string);

 /** @brief  Request that the library reads and returns the current board temperature
 *
 * @retval      LIDAR_LITE_SUCCESS      The temperature calculation was was initiated successfully
 *              LIDAR_LITE_ERROR_BUSY   The ADC resource is busy
 */
lidar_lite_return_t lidar_lite_get_temp();

 /** @brief     Retrieve the board temperature, this can be called after the first call to
 *              lidar_lite_get_temp()
 *
 * @retval      Board temperature in Celsius
 */
int8_t lidar_lite_retrieve_board_temperature();

 /** @brief     Retrieve the hardware version, this is known once the FPGA and board have powered up
 *
 * @retval      Board revision
 */
char lidar_lite_retrieve_hardware_version();

 /** @brief     Retrieve the FPGA version low byte
 *
 * @retval      FPGA version
 */
uint8_t lidar_lite_retrieve_fpga_version();

 /** @brief  Set the high and low byte for last measured distance
 *
 * @param[out]   high byte address for distance measurement
 * @param[out]   low byte address for distance measurement
 */
void lidar_lite_retrieve_last_measurement(uint8_t *high, uint8_t *low);



lidar_lite_return_t lidar_lite_request_fpga_version_high();
lidar_lite_return_t lidar_lite_request_fpga_version_low();


 /** @brief  Request to read from a FPGA register
 *
 * @param[in]   register_address                  The FPGA register address that will be read
 *
 * @retval      LIDAR_LITE_SUCCESS                The FPGA register read was successfully requested
 * @retval      LIDAR_LITE_ERROR_INCORRECT_STATE  A FPGA register read could not be started because the Lidar Lite Library is not in
 *                                                the correct state. This function can not be called while taking a distance measurement
 *                                                or while powering on the FPGA.
 */
lidar_lite_return_t lidar_lite_request_register_read(uint8_t register_address);

 /** @brief  Request to write to a FPGA register
 *
 * @param[in]   register_address                  The FPGA register address
 * @param[in]   value                             The value that will be written to the FPGA register
 *
 * @retval      LIDAR_LITE_SUCCESS                The FPGA register write was successfully requested
 * @retval      LIDAR_LITE_ERROR_INCORRECT_STATE  A FPGA register write could not be started because the Lidar Lite Library is not in
 *                                                the correct state. This function can not be called while taking a distance measurement
 *                                                or while powering on the FPGA.
 */
lidar_lite_return_t lidar_lite_request_register_write(uint8_t register_address, uint8_t value);

 /** @brief  Configure the power levels in the Library
 *
 * @param[in]   lidar_lite_power_config_t   power mode
 *
 * @retval      LIDAR_LITE_SUCCESS
 */
lidar_lite_return_t lidar_lite_configure_power_mode(lidar_lite_power_config_t power_mode);

 /** @brief  Configure the Acquistion Count in the Library
 *
 * @param[in]   count, value between 0x00 and 0xFF
 *
 * @retval      LIDAR_LITE_SUCCESS
 */
lidar_lite_return_t lidar_lite_set_acquisition_count(uint8_t count);

 /** @brief  Configure the Quick termination mode in the library
 *
 * @param[in]   lidar_lite_termination_config_t     mode
 *
 * @retval      LIDAR_LITE_SUCCESS
 */
lidar_lite_return_t lidar_lite_set_quick_termination_mode(lidar_lite_termination_config_t mode);

 /** @brief  Configure the high accuracy count in the library
 *
 * @param[in]   count : Value between 0x00 (OFF) to 0xFF
 *
 * @retval      LIDAR_LITE_SUCCESS
 */
lidar_lite_return_t lidar_lite_set_high_accuracy_count(uint8_t count);

 /** @brief  Retrieve a copy of the FPGA cache maintained by Library
 *
 * @param[in]   register_address:  register whose value is requested
 *
 * @retval      Value of register
 */
uint8_t lidar_lite_get_library_register_value(uint8_t register_address);


#endif

